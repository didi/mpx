<template>
  <view class="mpx-sticky-header-container">
    <view
      class="mpx-sticky-header"
      wx:style="{{isStickOnTop ? `position: fixed;top: ${scrollOffsetTop + offsetTop}px`: ''}}"
    >
      <slot></slot>
    </view>
    <view
      class="mpx-sticky-header-placeholder"
      id="{{stickyId}}"
      wx:style="{{isStickOnTop ? `position: relative;height: ${headerHeight}px;` : `position: absolute;height: ${headerHeight}px;`}}"
    ></view>
  </view>
</template>

<script>
  import mpx, { createComponent } from '@mpxjs/core'

  createComponent({
    properties: {
      offsetTop: {
        type: Number,
        value: 0
      },
      scrollViewId: {
        type: String,
        value: ''
      },
      stickyId: {
        type: String,
        value: ''
      }
    },
    data: {
      isStickOnTop: false,
      scrollOffsetTop: 0,
      headerHeight: 0,
      stickyHeader: '',
      headerTop: 0
    },
    ready() {
      if (!this.scrollViewId) {
        console.error('[mpx runtime error]: scroll-view-id is necessary property in ali environment')
      }
      if (!this.stickyId) {
        console.error('[mpx runtime error]: stickyId is necessary property in ali environment')
      }
      // 先获取元素的初始位置
      this.createSelectorQuery()
        .select('.mpx-sticky-header')
        .boundingClientRect((rect) => {
          if (!rect) return
          mpx
            .createSelectorQuery()
            .select(`#${this.scrollViewId}`)
            .boundingClientRect((res) => {
              if (!res) return
              this.scrollOffsetTop = res.top || 0
              this.headerHeight = rect.height
              this.headerTop = rect.top - this.scrollOffsetTop
              this.stickyHeader = my.createIntersectionObserver({
                thresholds: [0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1]
              })
              this.initTabsObserver()
            })
            .exec()
        })
        .exec()
    },
    methods: {
      initTabsObserver() {
        this.stickyHeader.relativeTo(`#${this.scrollViewId}`).observe(`#${this.stickyId}`, (res) => {
          const { intersectionRatio, intersectionRect, relativeRect } = res
          // 获取当前滚动位置
          mpx
            .createSelectorQuery()
            .select(`#${this.scrollViewId}`)
            .scrollOffset((scrollRes) => {
              const scrollTop = scrollRes.scrollTop
              if (scrollTop > this.headerTop) {
                if (intersectionRect.bottom < relativeRect.bottom) {
                  if (this.isStickOnTop) return
                  this.isStickOnTop = true
                  this.triggerEvent('stickontopchange', {
                    isStickOnTop: this.isStickOnTop,
                    id: this.stickyId
                  })
                }
              } else if (scrollTop <= this.headerTop) {
                if (!this.isStickOnTop) return
                this.isStickOnTop = false
                this.triggerEvent('stickontopchange', {
                  isStickOnTop: this.isStickOnTop,
                  id: this.stickyId
                })
              }
            })
            .exec()
        })
      },
      detached() {
        // 清理观察器
        if (this.stickyHeader) {
          this.stickyHeader.disconnect()
        }
      }
    }
  })
</script>
<style lang="stylus" scoped>
  .mpx-sticky-header-container
    position relative
  .mpx-sticky-header-placeholder
    position absolute
    left 0
    right 0
    top 0
    pointer-events none
  .mpx-sticky-header
    width 100%
</style>