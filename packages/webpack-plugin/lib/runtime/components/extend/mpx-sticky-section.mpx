<template>
  <view class="mpx-sticky-section">
    <view 
      class="sticky-placeholder" 
      style="height: {{isSticky ? contentHeight : 0}}px;"
    ></view>
    <view 
      id="{{id}}"
      wx:ref
      class="sticky-content {{isSticky ? 'is-sticky' : ''}}" 
      style="{{contentStyle}}"
    >
      <slot></slot>
    </view>
  </view>
</template>

<script>
import mpx, { createComponent } from '@mpxjs/core'

createComponent({
  properties: {
    // 吸顶时与顶部的距离，单位px
    offsetTop: {
      type: Number,
      value: 0
    },
    // 吸顶元素重叠时是否继续上推
    pushPinnedHeader: {
      type: Boolean,
      value: true
    },
    // 内边距 [top, right, bottom, left]
    padding: {
      type: Array,
      value: [0, 0, 0, 0]
    },
    // scroll-view的选择器
    scrollSelector: {
      type: String,
      value: ''
    },
    id: {
      type: String,
      value: ''
    }
  },

  data: {
    isSticky: false,
    contentHeight: 0,
    contentStyle: '',
    selectorQuery: null
  },

  computed: {
    baseStyle() {
      const { padding, offsetTop, isSticky } = this
      const [paddingTop, paddingRight, paddingBottom, paddingLeft] = padding
      
      return [
        isSticky ? `top: ${offsetTop}px;` : '',
        `padding: ${paddingTop}px ${paddingRight}px ${paddingBottom}px ${paddingLeft}px;`
      ].join('')
    }
  },

  lifetimes: {
    attached() {
      this.selectorQuery = mpx.createSelectorQuery().in(this)
      this.init()
    },
    
    detached() {
      this.cleanup()
    }
  },

  methods: {
    init() {
      query.select('.sticky-content')
        .boundingClientRect(rect => {
          if (rect) {
            this.contentHeight = rect.height
            this.setupObservers()
          }
        })
        .exec()
    },

    setupObservers() {
      let lastPushedOffset = 0

      const updateStickyState = () => {
        const getRects = () => {
            return new Promise((resolve) => {
            
            if (this.scrollSelector) {
              this.selectorQuery.select(`#${this.scrollSelector}`)
                .boundingClientRect()
                .selectAll('.sticky-content')
                .boundingClientRect()
                .exec(res => {
                  if (!res || !res[0] || !res[1]) {
                    resolve([])
                    return
                  }
                  
                  const scrollRect = res[0]
                  const contentRects = res[1]
                  
                  const adjustedRects = contentRects.map(rect => ({
                    ...rect,
                    relativeTop: rect.top - scrollRect.top
                  }))
                  resolve(adjustedRects)
                })
            }
          })
        }

        const updatePosition = async () => {
          const rects = await getRects()
          const currentRect = rects.find(rect => rect.id === this.id)
          if (!currentRect) return

          const shouldSticky = currentRect.relativeTop <= this.offsetTop

          if (this.isSticky !== shouldSticky) {
            this.isSticky = shouldSticky
            this.triggerEvent('stickontopchange', {
              isSticky: shouldSticky,
              height: currentRect.height
            })
          }

          if (this.pushPinnedHeader && shouldSticky) {
            const stickyRects = rects.filter(rect => {
              const el = this.selectorQuery.select(`#${rect.id}`)
              return el && el.hasClass('is-sticky')
            })
            
            const aboveHeaders = stickyRects.filter(rect => 
              rect.relativeTop < currentRect.relativeTop && 
              rect.id !== this.id
            )
            
            const totalPush = aboveHeaders.reduce((sum, rect) => sum + rect.height, 0)
            
            if (totalPush !== lastPushedOffset) {
              lastPushedOffset = totalPush
              this.contentStyle = this.baseStyle + (totalPush ? `transform: translateY(${totalPush}px);` : '')
            }
          }
        }

        updatePosition()
      }

      if (this.scrollSelector) {
        this.createIntersectionObserver({
          thresholds: [0, 1]
        })
        .relativeTo(`#${this.scrollSelector}`, {
          top: -this.offsetTop  // 设置观察的偏移量
        })
        .observe('.sticky-content', (res) => {
          if (res.intersectionRatio < 1) {
            updateStickyState()
          }
        })
      }

      // 触发初始状态检查
      updateStickyState()
    },

    cleanup() {
      if (this.intersectionObserver) {
        this.intersectionObserver.disconnect()
      }
    }
  }
})
</script>

<style lang="stylus">
.mpx-sticky-section
  position: relative
  
  .sticky-placeholder
    width: 100%
    transition: height 0.1s ease-in-out
  
  .sticky-content
    width: 100%
    z-index: 100
    box-sizing: border-box
    
    &.is-sticky
      position: fixed
      left: 0
</style>

<script type="application/json">
{
  "component": true
}
</script>