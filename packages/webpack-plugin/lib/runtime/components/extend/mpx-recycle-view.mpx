<template>
  <scroll-view
    class="mpx-recycle-view"
    wx:ref="mpxRecycleView"
    type="list"
    scroll-y="{{scrollY}}"
    scroll-top="{{_scrollTop}}"
    scroll-with-animation="{{scrollWithAnimation}}"
    enable-back-to-top="{{enableBackToTop}}"
    lower-threshold="{{lowerThreshold}}"
    upper-threshold="{{upperThreshold}}"
    scroll-options="{{scrollOptions}}"
    scrollEventThrottle="{{scrollEventThrottle}}"
    wx:style="width: {{_width}}; height: {{_height}}"
    bindscroll="onScroll"
    bindscrollend="onScrollEnd"
    bindscrolltoupper="onScrollToUpper"
    bindscrolltolower="onScrollToLower"
  >
    <view class="content-wrapper">
      <view class="infinite-list-placeholder" wx:style="{{placeholderStyle}}"></view>
      <view class="infinite-list" wx:style="{{contentStyle}}">
        <recycle-item wx:for="{{visibleData}}" wx:key="_index" current-item="{{item}}" />
      </view>
    </view>
  </scroll-view>
</template>
<script>
  import mpx, { createComponent } from '@mpxjs/core'

  createComponent({
    properties: {
      scrollY: Boolean,
      height: {
        type: Number,
        value: 0
      },
      width: {
        type: Number,
        value: 0
      },
      itemHeight: {
        type: Object,
        value: {}
      },
      bufferScale: {
        type: Number,
        value: 2
      },
      listData: Array,
      scrollTop: {
        type: Number,
        value: 0
      },
      scrollWithAnimation: Boolean,
      enableBackToTop: Boolean,
      lowerThreshold: {
        type: Number,
        value: 50
      },
      upperThreshold: {
        type: Number,
        value: 50
      },
      scrollOptions: {
        type: Object,
        value: {}
      },
      scrollEventThrottle: {
        type: Number,
        value: 0
      },
      minRenderCount: {
        type: Number,
        value: 10
      }
    },
    data: {
      start: 0,
      end: 0,
      contentStyle: '',
      placeholderStyle: '',
      containerHeight: 0,
      positions: [],
      isReady: false,
      lastScrollTime: 0,
      visibleCounts: []
    },
    computed: {
      _width() {
        return this.width ? `${this.width}px` : '100%'
      },
      _height() {
        return this.height ? `${this.height}px` : '100%'
      },
      _listData() {
        return this.listData.map((item, index) => {
          return Object.assign({}, item, { _index: `_${index}` })
        })
      },
      _scrollTop() {
        // 使用初始值或当前值
        return this.isReady ? this.scrollTop : 0
      },
      visibleCount() {
        if (!this.visibleCounts.length) return this.minRenderCount
        return Math.max(this.visibleCounts[this.start], this.minRenderCount)
      },
      aboveCount() {
        if (!this._listData.length || !this.visibleCounts.length) return 0
        let count = 0
        const startIndex = Math.max(0, this.start)
        const endIndex = Math.max(0, startIndex - this.bufferScale)

        for (let i = startIndex; i > endIndex; i--) {
          count += this.visibleCounts[i] || 0
        }

        return count
      },
      belowCount() {
        if (!this._listData.length || !this.visibleCounts.length) return 0
        let count = 0
        const startIndex = Math.min(this.start, this._listData.length - 1)
        const endIndex = Math.min(startIndex + this.bufferScale, this._listData.length - 1)

        for (let i = startIndex; i < endIndex; i++) {
          count += this.visibleCounts[i] || 0
        }

        return count
      },
      visibleData() {
        if (!this._listData.length) return []

        const start = Math.min(Math.max(0, this.start - this.aboveCount), this._listData.length - 1)

        let end = Math.min(this._listData.length, this.start + this.visibleCount + this.belowCount)

        // 如果接近列表末尾，确保显示所有剩余项目
        if (end > this._listData.length - 3) {
          end = this._listData.length
        }

        return this._listData.slice(start, end).map((item, idx) => {
          const realIndex = start + idx
          const height = this.getItemHeight(item, realIndex)
          return {
            ...item,
            _index: `_${realIndex}`
          }
        })
      },
      totalHeight() {
        if (!this.positions.length) return 0
        return this.positions[this.positions.length - 1].bottom
      }
    },
    watch: {
      listData: {
        handler() {
          this.initPositions()
          this.placeholderStyle = `height: ${this.totalHeight}px`
          // 更新真实偏移量
          this.setStartOffset()
        }
      },
      scrollTop: {
        handler(val) {
          this.start = this.getStartIndex(val)
          this.end = this.start + this.visibleCount
          this.setStartOffset()
        },
        immediate: true
      },
      containerHeight() {
        this.calculateVisibleCounts()
      }
    },
    ready() {
      this.initPositions()
      const query = mpx.createSelectorQuery().in(this)
      query
        .select('.mpx-recycle-view')
        .boundingClientRect((rect) => {
          this.containerHeight = rect.height
          this.isReady = true
          this.placeholderStyle = `height: ${this.totalHeight}px`
          if (!this.positions || !this.positions.length) {
            return
          }
          this.start = this.getStartIndex(this.scrollTop)
          this.end = this.start + this.visibleCount
          this.setStartOffset()
        })
        .exec()
    },
    methods: {
      initPositions() {
        let bottom = 0
        this.positions = this._listData.map((item, index) => {
          const height = this.getItemHeight(item, index)
          const position = {
            index,
            height: height,
            top: bottom,
            bottom: bottom + height
          }
          bottom = position.bottom
          return position
        })

        if (this.containerHeight) {
          this.calculateVisibleCounts()
        }
      },
      calculateVisibleCounts() {
        this.visibleCounts = this.positions.map((_, startIndex) => {
          let count = 0
          let totalHeight = 0

          for (let i = startIndex; i < this.positions.length; i++) {
            totalHeight += this.positions[i].height
            if (totalHeight > this.containerHeight) {
              break
            }
            count++
          }

          // 如果是最后几个项目，确保全部显示
          if (startIndex + count > this.positions.length - 3) {
            count = this.positions.length - startIndex
          }

          return count
        })
      },

      getStartIndex(scrollTop = 0) {
        // 确保不会返回超出范围的索引
        if (!this.positions.length) {
          return 0
        }

        // 如果滚动位置为0，直接返回0
        if (scrollTop <= 0) {
          return 0
        }
        const index = this.binarySearch(this.positions, scrollTop)
        return Math.max(0, Math.min(index, this._listData.length - 1))
      },
      binarySearch(list, value) {
        if (!list.length) return 0

        // 如果 scrollTop 超过了最后一个元素的底部
        if (value >= list[list.length - 1].bottom) {
          return list.length - 1
        }

        let start = 0
        let end = list.length - 1

        while (start <= end) {
          const midIndex = Math.floor((start + end) / 2)
          const midValue = list[midIndex]

          if (value >= midValue.top && value < midValue.bottom) {
            return midIndex
          }

          if (value < midValue.top) {
            end = midIndex - 1
          } else {
            start = midIndex + 1
          }
        }

        return Math.min(Math.max(0, start - 1), list.length - 1)
      },
      setStartOffset() {
        if (!this.positions.length) return

        if (this.start >= 1) {
          // 确保 startIndex 不会超出范围
          const startIndex = Math.min(
            Math.max(0, this.start - this.aboveCount),
            this.positions.length - 1
          )

          const offset = this.positions[startIndex].top

          this.contentStyle = `transform: translateY(${offset}px);`
        } else {
          this.contentStyle = `transform: translateY(0px);`
        }
      },
      getItemHeight(item, index) {
        const { value, getter } = this.itemHeight
        if (typeof getter === 'function') {
          return getter(item, index) || 0
        } else {
          return value || 0
        }
      },
      onScroll(e) {
        const now = Date.now()
        // 添加16ms的节流，大约60fps
        if (now - this.lastScrollTime < 16) {
          return
        }
        this.lastScrollTime = now

        const { scrollTop } = e.detail
        const newStart = this.getStartIndex(scrollTop)
        
        // 只有当start发生足够变化时才更新，避免滚动触发重渲染
        if (Math.abs(newStart - this.end) >= Math.floor(this.belowCount / 2)) {
          this.start = newStart
          this.end = this.start + this.visibleCount
          this.setStartOffset()
        }
        
        this.triggerEvent('scroll', e)
      },
      onScrollToUpper(e) {
        this.triggerEvent('scrolltoupper', e)
      },
      onScrollToLower(e) {
        this.triggerEvent('scrolltolower', e)
      },
      scrollTo(params = {}) {
        this.$refs.mpxRecycleView.node().exec(res => {
          if (res && res[0]) {
            res[0].node.scrollTo(params)
          }
        })
      }
    }
  })
</script>
<script type="application/json">
  {
    "component": true,
    "componentGenerics": {
      "recycle-item": {
        "default": "./mpx-recycle-item-default.mpx"
      }
    }
  }
</script>
<style scoped>
  .mpx-recycle-view {
    position: relative;
    overflow: hidden;
  }

  .content-wrapper {
    position: relative;
    width: 100%;
  }

  .infinite-list {
    left: 0;
    right: 0;
    /* 支付宝环境需要设置允许事件穿透, 否则滑不动 */
    /* @mpx-if (__mpx_mode__ === 'ali') */
    pointer-events: none;
    /* @mpx-endif */
    top: 0;
    position: absolute;
    will-change: transform;
    -webkit-backface-visibility: hidden;
    backface-visibility: hidden;
  }
</style>
