<template>
  <scroll-view
    class="mpx-recycle-view"
    wx:ref
    type="list"
    scroll-y="{{scrollY}}"
    scroll-top="{{_scrollTop}}"
    scroll-with-animation="{{scrollWithAnimation}}"
    enable-back-to-top="{{enableBackToTop}}"
    lower-threshold="{{lowerThreshold}}"
    upper-threshold="{{upperThreshold}}"
    scroll-options="{{scrollOptions}}"
    wx:style="width: {{_width}}; height: {{_height}}"
    bindscroll="onScroll"
    bindscrolltoupper="onScrollToUpper"
    bindscrolltolower="onScrollToLower"
    wx:if="{{_listData && _listData.length}}"
  >
    <view class="content-wrapper">
      <view class="infinite-list-placeholder" wx:style="{{placeholderStyle}}"></view>
      <view class="infinite-list" wx:style="{{contentStyle}}">
        <view
          wx:for="{{visibleData}}"
          wx:key="_index"
          class="infinite-list-item"
          wx:style="height: {{item._size.height}}; width: {{item._size.width}}; overflow: hidden"
        >
          <recycle-item current-item="{{item}}" />
        </view>
      </view>
    </view>
  </scroll-view>
</template>
<script>
  import mpx, { createComponent } from '@mpxjs/core'

  createComponent({
    properties: {
      scrollY: Boolean,
      height: {
        type: Number,
        value: 0
      },
      width: {
        type: Number,
        value: 0
      },
      itemSize: {
        type: Object,
        value: {}
      },
      bufferScale: {
        type: Number,
        value: 2
      },
      listData: Array,
      scrollTop: {
        type: Number,
        value: 0
      },
      scrollWithAnimation: Boolean,
      enableBackToTop: Boolean,
      lowerThreshold: {
        type: Number,
        value: 50
      },
      upperThreshold: {
        type: Number,
        value: 50
      },
      scrollOptions: {
        type: Object,
        value: {}
      },
      scrollThrottleDelay: {
        type: Number,
        value: 16
      },
      minRenderCount: {
        type: Number,
        value: 10
      }
    },
    data: {
      start: 0,
      end: 0,
      contentStyle: '',
      placeholderStyle: '',
      containerHeight: 0,
      positions: [],
      isReady: false,
      lastScrollTime: 0,
      visibleCounts: []
    },
    computed: {
      _width() {
        return this.width ? `${this.width}px` : '100%'
      },
      _height() {
        return this.height ? `${this.height}px` : '100%'
      },
      _listData() {
        return this.listData.map((item, index) => {
          return Object.assign({}, item, { _index: `_${index}` })
        })
      },
      _scrollTop() {
        // 使用初始值或当前值
        return this.isReady ? this.scrollTop : 0
      },
      visibleCount() {
        if (!this.visibleCounts.length) return this.minRenderCount
        return Math.max(this.visibleCounts[this.start], this.minRenderCount)
      },
      // visibleCount() {
      //   if (!this.positions.length) return 0

      //   let count = 0
      //   let totalHeight = 0
      //   const startIndex = Math.min(this.start, this.positions.length - 1)

      //   for (let i = startIndex; i < this.positions.length; i++) {
      //     totalHeight += this.positions[i]?.height || 0
      //     if (totalHeight > this.containerHeight) {
      //       break
      //     }
      //     count++
      //   }

      //   // 如果是最后几个项目，确保全部显示
      //   if (startIndex + count > this.positions.length - 3) {
      //     count = this.positions.length - startIndex
      //   }
      //   return Math.max(count, this.minRenderCount)
      // },
      aboveCount() {
        return Math.max(0, Math.min(this.start, this.bufferScale * this.visibleCount))
      },
      belowCount() {
        if (!this._listData.length) return 0
        return Math.max(
          0,
          Math.min(this._listData.length - this.end, this.bufferScale * this.visibleCount)
        )
      },
      visibleData() {
        if (!this._listData.length) return []

        const start = Math.min(Math.max(0, this.start - this.aboveCount), this._listData.length - 1)

        let end = Math.min(this._listData.length, this.start + this.visibleCount + this.belowCount)

        // 如果接近列表末尾，确保显示所有剩余项目
        if (end > this._listData.length - 3) {
          end = this._listData.length
        }

        return this._listData.slice(start, end).map((item, idx) => {
          const realIndex = start + idx
          const size = this.getItemSize(item, realIndex)
          return {
            ...item,
            _index: `_${realIndex}`,
            _size: {
              width: typeof size.width === 'number' ? `${size.width}px` : size.width,
              height: typeof size.height === 'number' ? `${size.height}px` : size.height
            }
          }
        })
      },
      totalHeight() {
        if (!this.positions.length) return 0
        return this.positions[this.positions.length - 1].bottom
      }
    },
    watch: {
      listData: {
        handler() {
          this.initPositions()
          this.$nextTick(() => {
            if (!this.positions || !this.positions.length) {
              return
            }
            // 更新列表总高度
            this.placeholderStyle = `height: ${this.totalHeight}px`
            if (!this.isReady) {
              this.$nextTick(() => {
                this.isReady = true
              })
            }
            // 更新真实偏移量
            this.setStartOffset()
          })
        },
        immediate: true
      },
      scrollTop: {
        handler(val) {
          this.start = this.getStartIndex(val)
          this.end = this.start + this.visibleCount
          this.setStartOffset()
        },
        immediate: true
      },
      containerHeight() {
        this.calculateVisibleCounts()
      }
    },
    ready() {
      this.initPositions()
      const query = mpx.createSelectorQuery().in(this)
      query
        .select('.mpx-recycle-view')
        .boundingClientRect((rect) => {
          this.containerHeight = rect.height
          this.start = this.getStartIndex(this.scrollTop)
          this.end = this.start + this.visibleCount
          this.setStartOffset()
        })
        .exec()
    },
    methods: {
      initPositions() {
        let bottom = 0
        this.positions = this._listData.map((item, index) => {
          const size = this.getItemSize(item, index)
          const position = {
            index,
            height: size.height,
            top: bottom,
            bottom: bottom + size.height
          }
          bottom = position.bottom
          return position
        })

        if (this.containerHeight) {
          this.calculateVisibleCounts()
        }
      },
      calculateVisibleCounts() {
        this.visibleCounts = this.positions.map((_, startIndex) => {
          let count = 0
          let totalHeight = 0

          for (let i = startIndex; i < this.positions.length; i++) {
            totalHeight += this.positions[i].height
            if (totalHeight > this.containerHeight) {
              break
            }
            count++
          }

          // 如果是最后几个项目，确保全部显示
          if (startIndex + count > this.positions.length - 3) {
            count = this.positions.length - startIndex
          }

          return count
        })
      },

      getStartIndex(scrollTop = 0) {
        // 确保不会返回超出范围的索引
        if (!this.positions.length) {
          return 0
        }

        // 如果滚动位置为0，直接返回0
        if (scrollTop <= 0) {
          return 0
        }
        const index = this.binarySearch(this.positions, scrollTop)
        return Math.max(0, Math.min(index, this._listData.length - 1))
      },
      binarySearch(list, value) {
        if (!list.length) return 0

        // 如果 scrollTop 超过了最后一个元素的底部
        if (value >= list[list.length - 1].bottom) {
          return list.length - 1
        }

        let start = 0
        let end = list.length - 1

        while (start <= end) {
          const midIndex = Math.floor((start + end) / 2)
          const midValue = list[midIndex]

          if (value >= midValue.top && value < midValue.bottom) {
            return midIndex
          }

          if (value < midValue.top) {
            end = midIndex - 1
          } else {
            start = midIndex + 1
          }
        }

        return Math.min(Math.max(0, start - 1), list.length - 1)
      },
      setStartOffset() {
        if (!this.positions.length) return

        if (this.start >= 1) {
          // 确保 startIndex 不会超出范围
          const startIndex = Math.min(
            Math.max(0, this.start - this.aboveCount),
            this.positions.length - 1
          )

          const offset = this.positions[startIndex].top

          this.contentStyle = `transform: translateY(${offset}px);`
        } else {
          this.contentStyle = `transform: translateY(0px);`
        }
      },
      getItemSize(item, index) {
        const { width, height, getter } = this.itemSize
        let size
        if (typeof getter === 'function') {
          size = getter(item, index)
        } else {
          size = {
            width: width || 0,
            height: height || 0
          }
        }
        return size
      },

      onScroll(e) {
        const now = Date.now()
        if (now - this.lastScrollTime < this.scrollThrottleDelay) {
          return
        }
        this.lastScrollTime = now
        const { scrollTop } = e.detail
        this.start = this.getStartIndex(scrollTop)
        this.end = this.start + this.visibleCount
        this.setStartOffset()
        this.triggerEvent('scroll', e)
      },
      onScrollToUpper(e) {
        this.triggerEvent('scrolltoupper', e)
      },
      onScrollToLower(e) {
        this.triggerEvent('scrolltolower', e)
      }
    }
  })
</script>
<script type="application/json">
  {
    "component": true,
    "componentGenerics": {
      "recycle-item": {
        "default": "./mpx-recycle-item-default.mpx"
      }
    }
  }
</script>
<style scoped>
  .mpx-recycle-view {
    position: relative;
    overflow: hidden;
  }

  .content-wrapper {
    position: relative;
    width: 100%;
  }

  .infinite-list {
    left: 0;
    right: 0;
    /* 支付宝环境需要设置允许事件穿透, 否则滑不动 */
    /* @mpx-if (__mpx_mode__ === 'ali') */
    pointer-events: none;
    /* @mpx-endif */
    top: 0;
    position: absolute;
    will-change: transform;
    -webkit-backface-visibility: hidden;
    backface-visibility: hidden;
  }
</style>
